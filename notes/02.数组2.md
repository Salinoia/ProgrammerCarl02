## 长度最小的子数组

[LeetCode 209 Minimum Size Subarray Sum](https://leetcode.cn/problems/minimum-size-subarray-sum/)

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int length = INT32_MAX;// 存储满足条件的最短子数组的长度，初始化为INT32_MAX，表示尚未找到符合条件的子数组
        int slowPtr = 0;
        int sums = 0;
        for(int fastPtr = 0; fastPtr < nums.size(); ++fastPtr){
            sums += nums[fastPtr];
            while(sums >= target){
                int subLength = fastPtr - slowPtr + 1;
                length = std::min(length, subLength);
                sums -= nums[slowPtr++];
            }
        }
        return length == INT32_MAX ? 0 : length;
    }
};
```

## 螺旋矩阵Ⅱ

[LeetCode 59 Spiral Matrix II](https://leetcode.cn/problems/spiral-matrix-ii)

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0));
        int x_start_index = 0;
        int y_start_index = 0;
        int x_end_index = n - 1;
        int y_end_index = n - 1;
        int value = 1;
        /*
            左闭右开区间环绕
            则围绕中心点四次循环，分别视为：
            [(x_start_index, y_start_index), (x_end_index, y_start_index)) 
            [(x_end_index, y_start_index), (x_end_index, y_end_index))
            [(x_end_index, y_end_index), (x_start_index, y_end_index))
            [(x_start_index, y_end_index), (x_start_index, y_start_index))
            若n为奇数，则中心存在一个单独的数需要最后循环结束后处理，偶数则不需要
        */
        int loopCount = n / 2;
        while(loopCount--){
            for(int i = x_start_index; i < x_end_index; ++i) res[y_start_index][i] = value++;
            for(int j = y_start_index; j < y_end_index; ++j) res[j][x_end_index] = value++;
            for(int i = x_end_index; i > x_start_index; --i) res[y_end_index][i] = value++;
            for(int j = y_end_index; j > y_start_index; --j) res[j][x_start_index] = value++;
            x_start_index++;
            y_start_index++;
            x_end_index--;
            y_end_index--;
        }
        if(n % 2) res[n / 2][n / 2] = n * n;
        return res;
    }
};
```

## 前缀和

[Prefix Sum](https://kamacoder.com/problempage.php?pid=1070)

```cpp
#include<iostream>
#include<vector>

int main(){
    // 前缀和的方法，相当于数据重新利用
    int n, leftEdge, rightEdge;
    std::cin >> n;
    std::vector<int> inputArray(n);
    int prefix = 0;
    std::vector<int> prefixSum(n, 0);
    for(int i = 0; i < n; ++i){
        // std::cin >> inputArray[i];
        scanf("%d", &inputArray[i]);
        prefix += inputArray[i];
        prefixSum[i] = prefix;
    }
   

    // while(std::cin >> leftEdge >> rightEdge){
    //     if(leftEdge == 0) std::cout << prefixSum[rightEdge] << "\n";
    //     else std::cout << prefixSum[rightEdge] - prefixSum[leftEdge - 1] << "\n";
    // }
    while(~scanf("%d%d", &leftEdge, &rightEdge)){
        if(leftEdge == 0) printf("%d\n", prefixSum[rightEdge]);
        else printf("%d\n", prefixSum[rightEdge] - prefixSum[leftEdge - 1]);
    }    
}
```

