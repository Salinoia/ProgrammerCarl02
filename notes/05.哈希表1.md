## 有效的字母异位词

[valid anagram](https://leetcode.cn/problems/valid-anagram/)

```cpp
#include<string>

class Solution {
public:
    bool isAnagram(std::string s, std::string t) {
        int hash_array[26] = {0};// 补强：手搓string?
        for(int i = 0; i < s.length(); ++i){
            hash_array[s[i] - 'a']++;// 仅记录二十六个字母出现的次数，无需在意具体是哪个字母
        }
        for(int i = 0; i < t.length(); ++i){
            hash_array[t[i] - 'a']--;
        }
        for(int i = 0; i < 26; ++i){
            if(hash_array[i] != 0){
                return false;
            }
        }
        return true;
    }
};
```

## 两个数组的交集

[intersection of two arrays](https://leetcode.cn/problems/intersection-of-two-arrays/description/)

```cpp
#include<unordered_set>
#include<vector>

using std::unordered_set;
using std::vector;
class Solution {
public:
    // vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    //     unordered_set<int> result_set;
    //     unordered_set<int> num_set(nums1.begin(), nums1.end());
    //     for(int num:nums2){
    //         if(num_set.find(num) != num_set.end()){
    //             result_set.insert(num);
    //         }
    //     }
    //     return vector<int>(result_set.begin(), result_set.end());
    // }

    vector<int> intersection(vector<int>& nums1, vector<int>& nums2){
        unordered_set<int> result_set;
        int hash_table[1010] = {0};
        for(int num:nums1){
        /*
        	Modern Cpp Feature
        	for (int i = 0; i < nums1.size();i++) {
        		int num = nums1[i];
        	}
       */
            hash_table[num] = 1;
        }
        for(int num:nums2){
            if(hash_table[num] == 1){
                result_set.insert(num);
            }
        }
        return vector<int>(result_set.begin(), result_set.end());
    }
};
```

## 快乐数

[happy number](https://leetcode.cn/problems/happy-number/description/)

```cpp
#include<unordered_map>
#include<vector>

using std::vector;

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        std::unordered_map<int, int> u_map;
        for(int i = 0; i < nums.size(); ++i){
            auto iter = u_map.find(target - nums[i]); // 针对每个number寻找其是否存在对应匹配的值
            if(iter != u_map.end()){
                return {iter->second, i};
            }
            u_map.insert(std::pair<int, int>(nums[i], i));
        }
        return {};
    }
};
```

